from utils import *
import numpy as np
from math import sqrt, pi
from PIL import Image
from scipy import ndimage
from PIL import ImageFilter
from PIL.ImageFilter import (
    BLUR, CONTOUR, DETAIL, EDGE_ENHANCE, EDGE_ENHANCE_MORE,
    EMBOSS, FIND_EDGES, SMOOTH, SMOOTH_MORE, SHARPEN
    )
import random

def randomTransform(X, Y0 , Y1 , param, save_path):
    """
        params : image X , labels Y , a dictionnary that contains the transformation that you want to apply,  save path for images generated by the datagen
        function : apply randomly different transformations on the image and labels
        return : new image and landmarks, with transformation
    """
    X = X.reshape(len(X),len(X[0]))
    Y0 = Y0.reshape(len(Y0),len(Y0[0]))
    Y1 = Y1.reshape(len(Y1),len(Y1[0]))

    if param['gaussian'] and random.randint(0,1):
         X = gaussianNoise(X, Y0, 1)

    if param['horizontal_switch'] and random.randint(0,1):
        # left go on right, right on left
        X = flipAxis(X, 1)
        Y0 = flipAxis(Y0, 1)
        Y1 = flipAxis(Y1, 1)

    if param['width_shift_range'] and random.randint(0,1):
        X, Y0 , Y1 = widthShiftRange(X, Y0 , Y1, 0)

    if param['height_shift_range'] and random.randint(0,1):
         X, Y0 , Y1 = heightShiftRange(X, Y0 , Y1, 0)

    if param['rotate'] and random.randint(0,1):
         X, Y0 , Y1 = rotateImage(X, Y0 , Y1)

    # if random.randint(0,1):
    #     if param['light'] and random.randint(0,1):
    #          X = lightImageOpti(X)
    # else:
    #     if param['dark'] and random.randint(0,1):
    #          X = darkImageOpti(X)

    if param['light'] and param['dark'] and random.randint(0,1):
        if random.randint(0,1):
            X = lightImageOpti(X)
        else :
            X = darkImageOpti(X)


    ## uncomment the following 4 lines to save images ###
    # if not os.path.exists(save_path):
    #     os.mkdir(save_path)
    # img = 255*X
    # img = Image.fromarray(img.astype('uint8'))
    # img_name = getNextImgName(save_path)
    # img.save(img_name)

    X = X.reshape(len(X),len(X[0]),1)
    Y0 = Y0.reshape(len(Y0),len(Y0[0]),1)
    Y1 = Y1.reshape(len(Y1),len(Y1[0]),1)

    return X, Y0 , Y1


def getNextImgName(path):
    """
        param : the path were images generated by the datagen are saved
        function : compute the name of a new image, according to those which already exist
        return : the name of the new image
    """
    list_img_names_with_extension = os.listdir(path)
    next_img_num = 1
    num = 1
    new_name = 'img_1.png'
    for name_with_extension in list_img_names_with_extension:
        name = name_with_extension.split(".")[0]
        num = int(name.split("_")[1])
        if num >= next_img_num:
            next_img_num = num +1
    new_name = 'img_'+str(next_img_num)+'.png'
    return path + '/' + new_name

def flipAxis(X, axis):
    """
        param : An image X, the axis around wich you want to flip X
        function : flip X around the axis
        return : the flipped image
    """
    X = X.swapaxes(axis,0)
    X = X[::-1, ...]
    X = X.swapaxes(0, axis)
    return X


def widthShiftRange(X, Y0 ,Y1 , convolution_size):
    """
        param : image X , labels Y , size of the convolution filter
        function : if X has column with only zero on its left and right borders, the function has a probability to move the image and labels on left or right
                   It takes into account a convolution_size by keeping at least convolution/2 columns with zeros on left and right
        return : new image and labels
    """
    border_size = convolution_size/2
    nb_black_columns = 0
    # move left
    if random.randint(0,1):
        #first we count the number of columns that contains only zeros on left
        left_pixels = X[:,border_size]
        while np.sum(left_pixels) == 0.0:
            nb_black_columns += 1
            left_pixels = X[:,border_size+nb_black_columns]
        # we move the image and labels up by a random integer between zero and number of black columns
        nb_move = random.randint(0,nb_black_columns)
        X = np.roll(X, -nb_move)
        Y0 = np.roll(Y0, -nb_move)
        Y1 = np.roll(Y1, -nb_move)
        # we replace left columns with zeros
        X[:,len(X[0])-nb_move:] = 0.0
        Y0[:,len(Y0[0])-nb_move:] = 0.0
        Y1[:,len(Y1[0])-nb_move:] = 0.0
    #move right
    else:
        # same but on right
        right_pixels = X[:,(len(X[0]))-1-border_size]
        while np.sum(right_pixels) == 0.0:
            nb_black_columns += 1
            right_pixels = X[:,len(X[0])-1-nb_black_columns-border_size]
        nb_move = random.randint(0,nb_black_columns)
        X = np.roll(X,nb_move)
        Y0 = np.roll(Y0, nb_move)
        Y1 = np.roll(Y1, nb_move)
        X[:,:nb_move] = 0.0
        Y0[:,:nb_move] = 0.0
        Y1[:,:nb_move] = 0.0
    return X, Y0 , Y1

def heightShiftRange(X,Y0, Y1, convolution_size):
    """
        param : image X , labels Y , size of the convolution filter
        function : if X has column with only zero on its top and bottom borders, the function has a probability to move the image and labels up or down
                   It takes into account a convolution_size by keeping at least convolution/2 rows with zeros on top and bottom
        return : new image and labels
    """
    border_size = convolution_size/2
    nb_black_rows = 0
    #move up
    if random.randint(0,1):
        #first we count the number of rows that contains only zeros
        up_pixels = X[border_size,:]
        while np.sum(up_pixels) == 0.0:
            nb_black_rows += 1
            up_pixels = X[border_size+nb_black_rows,:]
        # we move the image and labels up by a random integer between zero and number of black rows
        nb_move = random.randint(0,nb_black_rows)
        X = np.roll(X, -nb_move, axis = 0)
        Y0 = np.roll(Y0, -nb_move, axis = 0)
        Y1 = np.roll(Y1, -nb_move, axis = 0)
        # we replace bottom rows with zeros
        X[len(X)-nb_move:,:] = 0.0
        Y0[len(Y0)-nb_move:,:] = 0.0
        Y1[len(Y1)-nb_move:,:] = 0.0
    # move down
    else:
        # same but move down
        bottom_pixels = X[len(X)-1-border_size,:]
        while np.sum(bottom_pixels) == 0.0:
            nb_black_rows += 1
            bottom_pixels = X[len(X)-1-nb_black_rows-border_size,:]
        nb_move = random.randint(0,nb_black_rows)
        X = np.roll(X,nb_move, axis = 0)
        Y0 = np.roll(Y0,nb_move, axis = 0)
        Y1 = np.roll(Y1,nb_move, axis = 0)
        X[:nb_move,:] = 0.0
        Y0[:nb_move,:] = 0.0
        Y1[:nb_move,:] = 0.0
    return X, Y0 , Y1


def rotateImage(X, Y0 , Y1):
    """
        param : image X , labels Y
        function : Generate a random angle between -10 and 10 degrees, and rotate the image and its labels
        return : new image and labels
    """
    angle_degree = random.randint(-10,10)
    X = ndimage.rotate(X,angle_degree,reshape=False)
    Y0  = ndimage.rotate(Y0 ,angle_degree,reshape=False)
    Y1  = ndimage.rotate(Y1 ,angle_degree,reshape=False)
    return X, Y0 , Y1

def lightImageOpti(X):
    temporary_tab = np.zeros(X.shape, dtype = 'float')
    # max = np.amax(X)
    X = np.log ( (X * 3) + 1 )
    X = X / np.amax(X)
    return(X)

def darkImageOpti(X):
    temporary_tab = np.zeros(X.shape, dtype = 'float')
    max = np.amax(X)
    X = np.exp ( (X * 4) - 1 )
    X = X / np.amax(X)
    return(X)

def oldGaussianNoise(X, Y):
    height = X.shape[0]
    width = X.shape[1]

    line_sum = np.sum(X,axis=1)
    column_sum = np.sum(X,axis=0)
    line_no_black = np.where(line_sum>0)
    column_no_black = np.where(column_sum>0)

    p_1 = [line_no_black[0][0], column_no_black[0][0]]
    p_2 = [line_no_black[0][-1], column_no_black[0][-1]]

    step = 512/float(height)

    max_X = np.amax(X)
    max_Y = np.amax(Y)

    Y_line_sum = np.sum(Y[int(p_1[0] + (20 / step)):int(p_2[0] - (20 / step))+1],axis=1)
    Y_line_no_black = np.where(Y_line_sum>0)
    x = np.random.choice(Y_line_no_black[0]) + int(p_1[0] + (20/step))

    Y_column_no_black = np.where(Y[x]>0)
    column_aux = Y_column_no_black[0][0] + int(sum(Y[x]/max_Y)/2)
    y = max(random.randint(column_aux - (10 / step), column_aux + (10 / step)),1)

    max_gauss = max_X - X[x][y]
    sigma = 0.3
    I,J = np.meshgrid(np.abs(np.arange(0, (p_2[1] - p_1[1]) * step, step, dtype="float")-((y - p_1[1])*step)), np.abs(np.arange(0, (p_2[0] - p_1[0]) * step, step, dtype="float")-((x - p_1[0])*step)))
    X[p_1[0]:p_2[0],p_1[1]:p_2[1]] = np.minimum(X[p_1[0]:p_2[0],p_1[1]:p_2[1]] + max_gauss * np.exp(-5 * (((I / sqrt(x**2 + y**2))**2 + (J / sqrt(x**2 + y**2))**2) / ( 2.0 * sigma**2 ))), max_X)
    return(X)



def gaussianNoise(X, Y, max_nb_noise):
    height = X.shape[0]
    width = X.shape[1]

    nb_noise = random.randint(1,max_nb_noise)

    line_sum = np.sum(X,axis=1)
    column_sum = np.sum(X,axis=0)
    line_no_black = np.where(line_sum>0)
    column_no_black = np.where(column_sum>0)

    p_1 = [line_no_black[0][0], column_no_black[0][0]]
    p_2 = [line_no_black[0][-1], column_no_black[0][-1]]

    max_X = np.amax(X)
    max_Y = np.amax(Y)

    step = 512/float(height)

    Y_line_sum = np.sum(Y[int(p_1[0] + (20 / step)):int(p_2[0] - (20 / step))+1],axis=1)
    Y_line_no_black = np.where(Y_line_sum>0)

    nb_lines_no_black = len(Y_line_no_black[0])

    for n in range(nb_noise):

        boundary_inf = nb_lines_no_black/nb_noise*n
        boundary_sup = nb_lines_no_black/nb_noise*(n+1)

        x = np.random.choice(Y_line_no_black[0][boundary_inf:boundary_sup]) + int(p_1[0] + (20/step))
        Y_column_no_black = np.where(Y[x]>0)
        column_aux = Y_column_no_black[0][0] + int(sum(Y[x]/max_Y)/2)
        y = max(random.randint(column_aux - (10 / step), column_aux + (10 / step)),1)

        I, J = np.meshgrid(np.abs(np.arange(0, (p_2[1] - p_1[1]) * step, step, dtype="float")-((y - p_1[1])*step)), np.abs(np.arange(0, (p_2[0] - p_1[0]) * step, step, dtype="float")-((x - p_1[0])*step)))

        max_gauss = max_X - X[x][y]

        sigma = 0.3

        X[p_1[0]:p_2[0],p_1[1]:p_2[1]] = np.minimum(X[p_1[0]:p_2[0],p_1[1]:p_2[1]] + max_gauss * np.exp(-5 * nb_noise * (((I / sqrt(x**2 + y**2))**2 + (J / sqrt(x**2 + y**2))**2) / ( 2.0 * sigma**2 ))), 1)
    return(X)

def test(name_fct, images_path, save_path, labels_path = None, normalize = False):
    index = 0
    if not os.path.exists(save_path):
        os.mkdir(save_path)
    for image in os.listdir(images_path):
        print("IMAGE")
        print(image)
        print(index)
        imgpil = Image.open(os.path.join(images_path, image))
        name = image.split(".", 1)[0] + ".png"
        if (labels_path != None):
            imgpil2 = Image.open(os.path.join(labels_path, name))
            img2 = np.array(imgpil2, dtype = 'float')

        img = np.array(imgpil, dtype = 'float')

        if (normalize):
            max_img = np.amax(img)
            img = img/max_img

        if (name_fct == "dark"):
            img = darkImage(img)

        elif (name_fct == "light"):
            img = lightImage(img)

        elif (name_fct == "oldGaussian"):
            img = oldGaussianNoise(img, img2)

        elif (name_fct == "gaussian"):
            img = gaussianNoise(img, img2, 1)

        if (normalize):
            img = img * max_img

        img = Image.fromarray(img.astype('uint8'))
        img.save(os.path.join(save_path, name))
        index += 1

# test("oldGaussian", "../../../DATA/data/reduced_images_1024_256", "../../../DATA/data/test","../../../DATA/labels/training_distance_map/distance_map_white_12_1024_256", True)
# removeNoise("../../Final_code/Segmentation/final_en_cours","../../Final_code/Segmentation/final_improved_en_cours")
