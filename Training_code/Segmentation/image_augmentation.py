# from utils import *
import numpy as np
import random
import os
from math import sqrt, pi
from PIL import Image
from scipy import ndimage
from PIL import ImageFilter
from PIL.ImageFilter import (
    BLUR, CONTOUR, DETAIL, EDGE_ENHANCE, EDGE_ENHANCE_MORE,
    EMBOSS, FIND_EDGES, SMOOTH, SMOOTH_MORE, SHARPEN
    )

def randomTransform(X, Y0 , Y1 , param, save_path):
    """
        params : image X , labels Y , a dictionnary that contains the transformation that you want to apply,  save path for images generated by the datagen
        function : apply randomly different transformations on the image and labels
        return : new image and landmarks, with transformation
    """
    X = X.reshape(len(X),len(X[0]))
    Y0 = Y0.reshape(len(Y0),len(Y0[0]))
    Y1 = Y1.reshape(len(Y1),len(Y1[0]))

    if param['gaussian'] and random.randint(0,1):
         # X = oldGaussianNoise(X, Y0)
         X = gaussianNoise(X, Y0, 1)

    if param['horizontal_switch'] and random.randint(0,1):
        # left go on right, right on left
        X = flipAxis(X, 1)
        Y0 = flipAxis(Y0, 1)
        Y1 = flipAxis(Y1, 1)

    if param['width_shift_range'] and random.randint(0,1):
        X, Y0 , Y1 = widthShiftRange(X, Y0 , Y1, 0)

    if param['height_shift_range'] and random.randint(0,1):
         X, Y0 , Y1 = heightShiftRange(X, Y0 , Y1, 0)

    if param['rotate'] and random.randint(0,1):
         X, Y0 , Y1 = rotateImage(X, Y0 , Y1)

    if param['light'] and random.randint(0,1):
         X = lightImageOpti(X)

    if param['dark'] and random.randint(0,1):
         X = darkImageOpti(X)


    ### uncomment the following 4 lines to save images ###
    # img = X*255
    # img = Image.fromarray(img.astype('uint8'))
    # img_name = getNextImgName(save_path)
    # img.save(save_path + img_name)



    X = X.reshape(len(X),len(X[0]),1)
    Y0 = Y0.reshape(len(Y0),len(Y0[0]),1)
    Y1 = Y1.reshape(len(Y1),len(Y1[0]),1)



    return X, Y0 , Y1


def getNextImgName(path):
    """
        param : the path were images generated by the datagen are saved
        function : compute the name of a new image, according to those which already exist
        return : the name of the new image
    """
    list_img_names_with_extension = os.listdir(path)
    next_img_num = 1
    num = 1
    new_name = 'img_1.png'
    for name_with_extension in list_img_names_with_extension:
        name = name_with_extension.split(".")[0]
        num = int(name.split("_")[1])
        if num >= next_img_num:
            next_img_num = num +1
    new_name = 'img_'+str(next_img_num)+'.png'
    return new_name

def flipAxis(X, axis):
    """
        param : An image X, the axis around wich you want to flip X
        function : flip X around the axis
        return : the flipped image
    """
    X = X.swapaxes(axis,0)
    X = X[::-1, ...]
    X = X.swapaxes(0, axis)
    return X


def widthShiftRange(X, Y0 ,Y1 , convolution_size):
    """
        param : image X , labels Y , size of the convolution filter
        function : if X has column with only zero on its left and right borders, the function has a probability to move the image and labels on left or right
                   It takes into account a convolution_size by keeping at least convolution/2 columns with zeros on left and right
        return : new image and labels
    """
    border_size = convolution_size/2
    nb_black_columns = 0
    # move left
    if random.randint(0,1):
        #first we count the number of columns that contains only zeros on left
        left_pixels = X[:,border_size]
        while np.sum(left_pixels) == 0.0:
            nb_black_columns += 1
            left_pixels = X[:,border_size+nb_black_columns]
        # we move the image and labels up by a random integer between zero and number of black columns
        nb_move = random.randint(0,nb_black_columns)
        X = np.roll(X, -nb_move)
        Y0 = np.roll(Y0, -nb_move)
        Y1 = np.roll(Y1, -nb_move)
        # we replace left columns with zeros
        X[:,len(X[0])-nb_move:] = 0.0
        Y0[:,len(Y0[0])-nb_move:] = 0.0
        Y1[:,len(Y1[0])-nb_move:] = 0.0
    #move right
    else:
        # same but on right
        right_pixels = X[:,(len(X[0]))-1-border_size]
        while np.sum(right_pixels) == 0.0:
            nb_black_columns += 1
            right_pixels = X[:,len(X[0])-1-nb_black_columns-border_size]
        nb_move = random.randint(0,nb_black_columns)
        X = np.roll(X,nb_move)
        Y0 = np.roll(Y0, nb_move)
        Y1 = np.roll(Y1, nb_move)
        X[:,:nb_move] = 0.0
        Y0[:,:nb_move] = 0.0
        Y1[:,:nb_move] = 0.0
    return X, Y0 , Y1

def heightShiftRange(X,Y0, Y1, convolution_size):
    """
        param : image X , labels Y , size of the convolution filter
        function : if X has column with only zero on its top and bottom borders, the function has a probability to move the image and labels up or down
                   It takes into account a convolution_size by keeping at least convolution/2 rows with zeros on top and bottom
        return : new image and labels
    """
    border_size = convolution_size/2
    nb_black_rows = 0
    #move up
    if random.randint(0,1):
        #first we count the number of rows that contains only zeros
        up_pixels = X[border_size,:]
        while np.sum(up_pixels) == 0.0:
            nb_black_rows += 1
            up_pixels = X[border_size+nb_black_rows,:]
        # we move the image and labels up by a random integer between zero and number of black rows
        nb_move = random.randint(0,nb_black_rows)
        X = np.roll(X, -nb_move, axis = 0)
        Y0 = np.roll(Y0, -nb_move, axis = 0)
        Y1 = np.roll(Y1, -nb_move, axis = 0)
        # we replace bottom rows with zeros
        X[len(X)-nb_move:,:] = 0.0
        Y0[len(Y0)-nb_move:,:] = 0.0
        Y1[len(Y1)-nb_move:,:] = 0.0
    # move down
    else:
        # same but move down
        bottom_pixels = X[len(X)-1-border_size,:]
        while np.sum(bottom_pixels) == 0.0:
            nb_black_rows += 1
            bottom_pixels = X[len(X)-1-nb_black_rows-border_size,:]
        nb_move = random.randint(0,nb_black_rows)
        X = np.roll(X,nb_move, axis = 0)
        Y0 = np.roll(Y0,nb_move, axis = 0)
        Y1 = np.roll(Y1,nb_move, axis = 0)
        X[:nb_move,:] = 0.0
        Y0[:nb_move,:] = 0.0
        Y1[:nb_move,:] = 0.0
    return X, Y0 , Y1


def rotateImage(X, Y0 , Y1):
    """
        param : image X , labels Y
        function : Generate a random angle between -10 and 10 degrees, and rotate the image and its labels
        return : new image and labels
    """
    angle_degree = random.randint(-15,15)
    X = ndimage.rotate(X,angle_degree,reshape=False)
    Y0  = ndimage.rotate(Y0 ,angle_degree,reshape=False)
    Y1  = ndimage.rotate(Y1 ,angle_degree,reshape=False)
    return X, Y0 , Y1

def lightImage(X):
    temporary_tab = np.zeros(X.shape, dtype = 'float')
    max = np.amax(X) + 1
    for i in range(X.shape[0]):
        for j in range(X.shape[1]):
            X[i][j] = X[i][j] / max
            X[i][j] = X[i][j] * 9
            X[i][j] = X[i][j] + 1
            temporary_tab[i][j] = np.log(X[i][j])

    max = np.amax(temporary_tab)
    for i in range(X.shape[0]):
        for j in range(X.shape[1]):
            temporary_tab[i][j] = temporary_tab[i][j] / max
            X[i][j] = temporary_tab[i][j] * 255
    return(X)


def lightImageOpti(X):
    temporary_tab = np.zeros(X.shape, dtype = 'float')
    # max = np.amax(X)
    X = np.log ( (X * 3) + 1 )
    X = X / np.amax(X)
    return(X)


def darkImage(X):
    temporary_tab = np.zeros(X.shape, dtype = 'float')
    max = np.amax(X)
    for i in range(temporary_tab.shape[0]):
        for j in range(temporary_tab.shape[1]):
            X[i][j] = X[i][j] / max
            X[i][j] = X[i][j] * 3
            temporary_tab[i][j] = np.exp(X[i][j]) - 1

    max = np.amax(temporary_tab)
    for i in range(temporary_tab.shape[0]):
        for j in range(temporary_tab.shape[1]):
            temporary_tab[i][j] = temporary_tab[i][j] / max
            X[i][j] = temporary_tab[i][j] * 255

    return(X)

def darkImageOpti(X):
    temporary_tab = np.zeros(X.shape, dtype = 'float')
    max = np.amax(X)
    X = np.exp ( (X * 4) - 1 )
    X = X / np.amax(X)
    return(X)

def oldGaussianNoise(X):
    height = X.shape[0]
    width = X.shape[1]

    p_1 = [0, 0]
    p_2 = [height - 1, width - 1]

    while (np.sum(X[p_1[0]]) == 0) :
        p_1[0] += 1

    while (np.sum(X[:,p_1[1]]) == 0) :
        p_1[1] += 1

    while (np.sum(X[p_2[0]]) == 0) :
        p_2[0] -= 1

    while (np.sum(X[:,p_2[1]]) == 0) :
        p_2[1] -= 1

    # y = random.randint((p_2[1] - p_1[1]) / 4 + p_1[1] + 20, p_1[1] - 20 + 3 * (p_2[1] - p_1[1]) / 4)
    # x = random.randint(p_1[0] + 20, p_2[0] - 20)
    x = 150
    y = 60
    if (x == 0):
        x += 1
    if (y == 0):
        y += 1
    center = [x, y]

    R = min(50, abs(x-p_1[0]), abs(x-p_2[0]))

    max = np.amax(X)
    max_gauss = max - X[x][y]

    # x = float(x)
    # y = float(y)
    sigma = 0.3
    # gaussian_matrix = np.zeros((p_2[0] - p_1[0], p_2[1] - p_1[1]))
    gaussian_matrix = np.zeros((2*R, width))
    # for i in range(gaussian_matrix.shape[0]):
    #     for j in range(gaussian_matrix.shape[1]):
    #         gaussian_matrix[i][j] =  max_gauss * np.exp(-10 * (((float(i - (x - p_1[0])) / sqrt(x**2 + y**2))**2 + ((float(j - (y - p_1[1]))) / sqrt(x**2 + y**2))**2) / (2 * sigma**2)))
    #         X[i + p_1[0]][j + p_1[1]] += gaussian_matrix[i][j]
    #         if (X[i + p_1[0]][j + p_1[1]] > 255):
    #             X[i + p_1[0]][j + p_1[1]] = 255
    for i in range(x-R,x+R):
        for j in range(width):
            gaussian_matrix[i - x + R][j] =  max_gauss * np.exp(-40 * (((float(abs(i - x)) / sqrt(x**2 + y**2))**2 + ((float(abs(j - y))) / sqrt(x**2 + y**2))**2) / (2 * sigma**2)))
            X[i][j] += gaussian_matrix[i - x + R][j]
            if (X[i][j] > max):
                X[i][j] = max
    return(X)

def oldGaussianNoise2(X, Y):
    height = X.shape[0]
    width = X.shape[1]

    line_sum = np.sum(X,axis=1)
    column_sum = np.sum(X,axis=0)
    line_no_black = np.where(line_sum>0)
    column_no_black = np.where(column_sum>0)

    p_1 = [line_no_black[0][0], column_no_black[0][0]]
    p_2 = [line_no_black[0][-1], column_no_black[0][-1]]

    step = 512/float(height)

    max_X = np.amax(X)
    max_Y = np.amax(Y)

    Y_line_sum = np.sum(Y[int(p_1[0] + (20 / step)):int(p_2[0] - (20 / step))+1],axis=1)
    Y_line_no_black = np.where(Y_line_sum>0)
    x = np.random.choice(Y_line_no_black[0]) + int(p_1[0] + (20/step))

    Y_column_no_black = np.where(Y[x]>0)
    column_aux = Y_column_no_black[0][0] + int(sum(Y[x]/max_Y)/2)
    y = max(random.randint(column_aux - (10 / step), column_aux + (10 / step)),1)

    max_gauss = max_X - X[x][y]
    sigma = 0.3
    mu = 0
    I,J = np.meshgrid(np.abs(np.arange(0, (p_2[1] - p_1[1]) * step, step, dtype="float")-((y - p_1[1])*step)), np.abs(np.arange(0, (p_2[0] - p_1[0]) * step, step, dtype="float")-((x - p_1[0])*step)))
    X[p_1[0]:p_2[0],p_1[1]:p_2[1]] = np.minimum(X[p_1[0]:p_2[0],p_1[1]:p_2[1]] + max_gauss * np.exp(-5 * (((I / sqrt(x**2 + y**2))**2 + (J / sqrt(x**2 + y**2))**2) / ( 2.0 * sigma**2 ))), max_X)
    return(X)



def gaussianNoise(X, Y, max_nb_noise):
    height = X.shape[0]
    width = X.shape[1]

    nb_noise = random.randint(1,max_nb_noise)

    line_sum = np.sum(X,axis=1)
    column_sum = np.sum(X,axis=0)
    line_no_black = np.where(line_sum>0)
    column_no_black = np.where(column_sum>0)

    p_1 = [line_no_black[0][0], column_no_black[0][0]]
    p_2 = [line_no_black[0][-1], column_no_black[0][-1]]

    max_X = np.amax(X)
    max_Y = np.amax(Y)

    step = 512/float(height)

    Y_line_sum = np.sum(Y[int(p_1[0] + (20 / step)):int(p_2[0] - (20 / step))+1],axis=1)
    Y_line_no_black = np.where(Y_line_sum>0)

    nb_lines_no_black = len(Y_line_no_black[0])

    for n in range(nb_noise):

        boundary_inf = nb_lines_no_black/nb_noise*n
        boundary_sup = nb_lines_no_black/nb_noise*(n+1)

        # x = np.random.choice(Y_line_no_black[0][boundary_inf:boundary_sup]) + int(p_1[0] + (20/step))
        x = 300
        Y_column_no_black = np.where(Y[x]>0)
        column_aux = Y_column_no_black[0][0] + int(sum(Y[x]/max_Y)/2)
        # y = max(random.randint(column_aux - (10 / step), column_aux + (10 / step)),1)
        y = 120

        I, J = np.meshgrid(np.abs(np.arange(0, (p_2[1] - p_1[1]) * step, step, dtype="float")-((y - p_1[1])*step)), np.abs(np.arange(0, (p_2[0] - p_1[0]) * step, step, dtype="float")-((x - p_1[0])*step)))

        max_gauss = max_X - X[x][y]

        sigma = 0.3

        X[p_1[0]:p_2[0],p_1[1]:p_2[1]] = np.minimum(X[p_1[0]:p_2[0],p_1[1]:p_2[1]] + max_gauss * np.exp(-10 * nb_noise * (((I / sqrt(x**2 + y**2))**2 + (J / sqrt(x**2 + y**2))**2) / ( 2.0 * sigma**2 ))), 1)
    return(X)

def removeNoise(source_path,save_path):
    height_filter = 35
    width_filter = 10
    if not os.path.exists(save_path):
        os.mkdir(save_path)
    for image in os.listdir(source_path):
        print(image)
        imgpil = Image.open(os.path.join(source_path, image))
        img = np.array(imgpil, dtype = "float")
        height_image = img.shape[0] - 1
        width_image = img.shape[1] - 1

        step = float(height_image)/512.0
        height_filter = int(35 * step)
        width_filter = int(10 * step)

        img = (img > 25)*img

        img[:,0] = 0
        img[:,width_image] = 0
        img[0,:] = 0
        img[height_image,:] = 0

        i = 0
        while i < img.shape[0]-1:
            j = 0
            while j < img.shape[1]-1:
                if (sum(img[max(0,i-height_filter), max(0,j-width_filter):min(width_image, j+width_filter)]) + sum(img[min(height_image, i+height_filter), max(0,j-width_filter):min(width_image, j+width_filter)]) == 0):
                    if (sum(img[max(0,i-height_filter):min(height_image, i+height_filter), max(0,j-width_filter)]) == 0 and sum(img[max(0,i-height_filter):min(height_image, i+height_filter), min(width_image, j+width_filter)]) == 0):
                        img[max(0,i-height_filter):min(height_image, i+height_filter), max(0,j-width_filter):min(width_image, j+width_filter)] = np.zeros((min(height_image, i+height_filter) - max(0,i-height_filter), min(width_image, j+width_filter) - max(0,j-width_filter)))
                        j += width_filter / 2
                    else:
                        j +=1
                else:
                    j += 1
            i += 1

        img = (img > 0)*255

        imgpil = Image.fromarray(img.astype('uint8'))
        imgpil.save(os.path.join(save_path, image))



def test(name_fct, images_path, save_path, labels_path = None, normalize = False):
    index = 0
    for image in os.listdir(images_path):
        print("IMAGE")
        print(image)
        print(index)
        imgpil = Image.open(os.path.join(images_path, image))
        name = image.split(".", 1)[0] + ".png"
        if (labels_path != None):
            imgpil2 = Image.open(os.path.join(labels_path, name))
            img2 = np.array(imgpil2, dtype = 'float')

        img = np.array(imgpil, dtype = 'float')

        if (normalize):
            max_img = np.amax(img)
            img = img/max_img

        if (name_fct == "dark"):
            img = darkImage(img)

        elif (name_fct == "light"):
            img = lightImage(img)

        elif (name_fct == "oldGaussian"):
            img = oldGaussianNoise(img)

        elif (name_fct == "gaussian"):
            img = gaussianNoise(img, img2, 1)

        if (normalize):
            img = img * max_img

        img = Image.fromarray(img.astype('uint8'))
        img.save(os.path.join(save_path, name))
        index += 1
    return(0)

# test("gaussian", "../../../DATA/data/training_distance_map/reduced_images_1024_256", "../../../DATA/data/test_fct/img_aug/new_gaussian","../../../DATA/labels/training_distance_map/distance_map_white_6_1024_256", True)
# removeNoise("../../Final_code/Segmentation/AXEL/36_46-48-50-52-53","../../Final_code/Segmentation/AXEL/36_46-48-50-52-53_improved")
# removeNoise("../../Final_code/Segmentation/AXEL/36_35-54-58-60-64","../../Final_code/Segmentation/AXEL/36_35-54-58-60-64_improved")
removeNoise("../../Final_code/Segmentation/BENJ/input/36_1_3_26_31_48","../../Final_code/Segmentation/BENJ/output/36_1_3_26_31_48")
