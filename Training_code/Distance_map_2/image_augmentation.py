from utils import *
import numpy as np
from PIL import Image
from scipy import ndimage
from math import sqrt, pi
from PIL import ImageFilter
from PIL.ImageFilter import (
    BLUR, CONTOUR, DETAIL, EDGE_ENHANCE, EDGE_ENHANCE_MORE,
    EMBOSS, FIND_EDGES, SMOOTH, SMOOTH_MORE, SHARPEN
    )

def randomTransform(X,Y, param, save_path):
    """
        params : image X , labels Y , a dictionnary that contains the transformation that you want to apply,  save path for images generated by the datagen
        function : apply randomly different transformations on the image and labels
        return : new image and landmarks, with transformation
    """
    X = X.reshape(len(X),len(X[0]))
    Y = Y.reshape(len(Y),len(Y[0]))
    if param['horizontal_switch'] and random.randint(0,1):
        # left go on right, right on left
        X = flipAxis(X, 1)
        Y = flipAxis(Y, 1)

    if param['width_shift_range'] and random.randint(0,1):
        X, Y = widthShiftRange(X, Y, 0)

    if param['height_shift_range'] and random.randint(0,1):
         X, Y = heightShiftRange(X, Y, 0)

    if param['rotate'] and random.randint(0,1):
         X,Y = rotateImage(X,Y)

    if param['gaussian'] and random.randint(0,1):
        X = gaussianNoiseNetwork2(X)

    if param['holes'] and random.randint(0,1):
        X = holes(X)
    ### uncomment the following 4 lines to save images ###
    # img = X
    # img = Image.fromarray(img.astype('uint8'))
    # img_name = getNextImgName(save_path)
    # img.save(save_name)

    X = X.reshape(len(X),len(X[0]),1)
    Y = Y.reshape(len(Y),len(Y[0]),1)
    return X,Y


def getNextImgName(path):
    """
        param : the path were images generated by the datagen are saved
        function : compute the name of a new image, according to those which already exist
        return : the name of the new image
    """
    list_img_names_with_extension = os.listdir(path)
    next_img_num = 1
    num = 1
    new_name = 'img_1.png'
    for name_with_extension in list_img_names_with_extension:
        name = name_with_extension.split(".")[0]
        num = int(name.split("_")[1])
        if num >= next_img_num:
            next_img_num = num +1
    new_name = 'img_'+str(next_img_num)+'.png'
    return new_name

def flipAxis(X, axis):
    """
        param : An image X, the axis around wich you want to flip X
        function : flip X around the axis
        return : the flipped image
    """
    X = X.swapaxes(axis,0)
    X = X[::-1, ...]
    X = X.swapaxes(0, axis)
    return X


def widthShiftRange(X, Y, convolution_size):
    """
        param : image X , labels Y , size of the convolution filter
        function : if X has column with only zero on its left and right borders, the function has a probability to move the image and labels on left or right
                   It takes into account a convolution_size by keeping at least convolution/2 columns with zeros on left and right
        return : new image and labels
    """
    border_size = convolution_size/2
    nb_black_columns = 0
    # move left
    if random.randint(0,1):
        #first we count the number of columns that contains only zeros on left
        left_pixels = X[:,border_size]
        while np.sum(left_pixels) == 0.0:
            nb_black_columns += 1
            left_pixels = X[:,border_size+nb_black_columns]
        # we move the image and labels up by a random integer between zero and number of black columns
        nb_move = random.randint(0,nb_black_columns)
        X = np.roll(X, -nb_move)
        Y = np.roll(Y, -nb_move)
        # we replace left columns with zeros
        X[:,len(X[0])-nb_move:] = 0.0
        Y[:,len(Y[0])-nb_move:] = 0.0
    #move right
    else:
        # same but on right
        right_pixels = X[:,(len(X[0]))-1-border_size]
        while np.sum(right_pixels) == 0.0:
            nb_black_columns += 1
            right_pixels = X[:,len(X[0])-1-nb_black_columns-border_size]
        nb_move = random.randint(0,nb_black_columns)
        X = np.roll(X,nb_move)
        Y = np.roll(Y,nb_move)
        X[:,:nb_move] = 0.0
        Y[:,:nb_move] = 0.0
    return X, Y

def heightShiftRange(X,Y, convolution_size):
    """
        param : image X , labels Y , size of the convolution filter
        function : if X has column with only zero on its top and bottom borders, the function has a probability to move the image and labels up or down
                   It takes into account a convolution_size by keeping at least convolution/2 rows with zeros on top and bottom
        return : new image and labels
    """
    border_size = convolution_size/2
    nb_black_rows = 0
    #move up
    if random.randint(0,1):
        #first we count the number of rows that contains only zeros
        up_pixels = X[border_size,:]
        while np.sum(up_pixels) == 0.0:
            nb_black_rows += 1
            up_pixels = X[border_size+nb_black_rows,:]
        # we move the image and labels up by a random integer between zero and number of black rows
        nb_move = random.randint(0,nb_black_rows)
        X = np.roll(X, -nb_move, axis = 0)
        Y = np.roll(Y, -nb_move, axis = 0)
        # we replace bottom rows with zeros
        X[len(X)-nb_move:,:] = 0.0
        Y[len(Y)-nb_move:,:] = 0.0
    # move down
    else:
        # same but move down
        bottom_pixels = X[len(X)-1-border_size,:]
        while np.sum(bottom_pixels) == 0.0:
            nb_black_rows += 1
            bottom_pixels = X[len(X)-1-nb_black_rows-border_size,:]
        nb_move = random.randint(0,nb_black_rows)
        X = np.roll(X,nb_move, axis = 0)
        Y = np.roll(Y,nb_move, axis = 0)
        X[:nb_move,:] = 0.0
        Y[:nb_move,:] = 0.0
    return X, Y


def rotateImage(X, Y):
    """
        param : image X , labels Y
        function : Generate a random angle between -10 and 10 degrees, and rotate the image and its labels
        return : new image and labels
    """
    angle_degree = random.randint(-10,10)
    X = ndimage.rotate(X,angle_degree,reshape=False)
    Y = ndimage.rotate(Y,angle_degree,reshape=False)
    return X, Y

def gaussianNoiseNetwork2(X):
    height = X.shape[0]
    width = X.shape[1]

    max_gauss = np.amax(X) - random.randint(10, 80)
    sigma = 0.4

    nb_mark = random.randint(1, 5)

    for n in range (nb_mark):
        x = random.randint(height/4, 3*height/4)
        y = random.randint(width/4, 3*width/4)
        while (y == x):
            y = random.randint(width/4, 3*width/4)
        center = [x, y]
        height_mark = random.randint(1, 50)
        width_mark = random.randint(1, 8)
        gaussian_matrix = np.zeros((height_mark, width_mark))
        for i in range(gaussian_matrix.shape[0]):
            for j in range(gaussian_matrix.shape[1]):
                gaussian_matrix[i][j] =  max_gauss * np.exp(-1 * (((float(i - gaussian_matrix.shape[0]/2) / sqrt((gaussian_matrix.shape[0]/2.0)**2 + (gaussian_matrix.shape[1]/2.0)**2))**2 + ((float(j - gaussian_matrix.shape[1]/2.0)) / sqrt((gaussian_matrix.shape[0]/2.0)**2 + (gaussian_matrix.shape[1]/2.0)**2))**2) / (2 * sigma**2)))
                X[i + (x - height_mark/2)][j + (y + width_mark/2)] += gaussian_matrix[i][j]
                if (X[i + (x - height_mark/2)][j + (y + width_mark/2)] > 255):
                    X[i + (x - height_mark/2)][j + (y + width_mark/2)] = 255
    return(X)

def holes(X):
    height = X.shape[0]
    width = X.shape[1]
    shape = random.randint(10, 50)

    x = random.randint(height/4, 3*height/4)
    X[x:(x+shape),:] = np.zeros((shape, width))
    return(X)

# index = 0
# for image in os.listdir("../../Final_code/Distance_map_2/Final_results"): # "../../../DATA/data/preprocess/reduced_images_512_128"
#     print("IMAGE")
#     print(image)
#     print(index)
#     imgpil = Image.open(os.path.join("../../Final_code/Distance_map_2/Final_results", image))
#     img = np.array(imgpil, dtype = 'float')
#     img = holes(img)
#     img = Image.fromarray(img.astype('uint8'))
#     name = image.split(".", 1)[0]
#     img.save(os.path.join("../../../DATA/data/test_fct/img_aug/holes", name + ".png"))
#     index += 1
